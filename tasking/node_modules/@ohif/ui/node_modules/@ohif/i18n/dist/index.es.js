import i18n from 'i18next';
import LanguageDetector from 'i18next-browser-languagedetector';
import { initReactI18next } from 'react-i18next';

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  module.exports
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

var regenerator = runtime_1;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

var asyncToGenerator = _asyncToGenerator;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty;

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      defineProperty(target, key, source[key]);
    });
  }

  return target;
}

var objectSpread = _objectSpread;

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty$1(target, key, source[key]);
    });
  }

  return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this,
        args = arguments;

    var later = function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
}

function getLastOfPath(object, path, Empty) {
  function cleanKey(key) {
    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
  }

  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');

  while (stack.length > 1) {
    if (!object) return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty) object[key] = new Empty();
    object = object[key];
  }

  if (!object) return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}

function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object),
      obj = _getLastOfPath.obj,
      k = _getLastOfPath.k;

  obj[k] = newValue;
}
function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object),
      obj = _getLastOfPath2.obj,
      k = _getLastOfPath2.k;

  obj[k] = obj[k] || [];
  if (concat) obj[k] = obj[k].concat(newValue);
  if (!concat) obj[k].push(newValue);
}
function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path),
      obj = _getLastOfPath3.obj,
      k = _getLastOfPath3.k;

  if (!obj) return undefined;
  return obj[k];
}
var regexp = new RegExp('\{\{(.+?)\}\}', 'g');

function makeString(object) {
  if (object == null) return '';
  return '' + object;
}

function interpolate(str, data, lng) {
  var match, value;

  function regexSafe(val) {
    return val.replace(/\$/g, '$$$$');
  } // regular escape on demand


  while (match = regexp.exec(str)) {
    value = match[1].trim();
    if (typeof value !== 'string') value = makeString(value);
    if (!value) value = '';
    value = regexSafe(value);
    str = str.replace(match[0], data[value] || value);
    regexp.lastIndex = 0;
  }

  return str;
}

function ajax(url, options, callback, data, cache) {
  try {
    var x = new (XMLHttpRequest || ActiveXObject)('MSXML2.XMLHTTP.3.0');
    x.open(data ? 'POST' : 'GET', url, 1);

    if (!options.crossDomain) {
      x.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
    }

    if (options.authorize && options.apiKey) {
      x.setRequestHeader('Authorization', options.apiKey);
    }

    if (data || options.setContentTypeJSON) {
      x.setRequestHeader('Content-type', 'application/json');
    }

    x.onreadystatechange = function () {
      x.readyState > 3 && callback && callback(x.responseText, x);
    };

    x.send(JSON.stringify(data));
  } catch (e) {
    window.console && console.log(e);
  }
}

function getDefaults() {
  return {
    loadPath: 'https://api.locize.io/{{projectId}}/{{version}}/{{lng}}/{{ns}}',
    privatePath: 'https://api.locize.io/private/{{projectId}}/{{version}}/{{lng}}/{{ns}}',
    pullPath: 'https://api.locize.io/pull/{{projectId}}/{{version}}/{{lng}}/{{ns}}',
    getLanguagesPath: 'https://api.locize.io/languages/{{projectId}}',
    addPath: 'https://api.locize.io/missing/{{projectId}}/{{version}}/{{lng}}/{{ns}}',
    updatePath: 'https://api.locize.io/update/{{projectId}}/{{version}}/{{lng}}/{{ns}}',
    referenceLng: 'en',
    crossDomain: true,
    setContentTypeJSON: false,
    version: 'latest',
    pull: false,
    "private": false,
    whitelistThreshold: 0.9,
    failLoadingOnEmptyJSON: false,
    // useful if using chained backend
    allowedAddOrUpdateHosts: ['localhost']
  };
}

var I18NextLocizeBackend =
/*#__PURE__*/
function () {
  function I18NextLocizeBackend(services, options, callback) {
    _classCallCheck(this, I18NextLocizeBackend);

    if (services && services.projectId) {
      this.init(null, services, {}, options);
    } else {
      this.init(null, options, {}, callback);
    }

    this.type = 'backend';
  }

  _createClass(I18NextLocizeBackend, [{
    key: "init",
    value: function init(services) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var callback = arguments.length > 3 ? arguments[3] : undefined;
      this.options = _objectSpread$1({}, getDefaults(), this.options, options); // initial

      if (this.options.pull) console.warn('deprecated: pull will be removed in future versions and should be replaced with locize private versions');
      var hostname = window.location && window.location.hostname;

      if (hostname) {
        this.isAddOrUpdateAllowed = this.options.allowedAddOrUpdateHosts.indexOf(hostname) > -1;
      } else {
        this.isAddOrUpdateAllowed = true;
      }

      if (typeof callback === 'function') {
        this.getOptions(function (err, opts) {
          if (err) return callback(err);
          _this.options.referenceLng = options.referenceLng || opts.referenceLng || _this.options.referenceLng;
          callback(null, opts);
        });
      }

      this.queuedWrites = {};
      this.debouncedProcess = debounce(this.process, 10000);
    }
  }, {
    key: "getLanguages",
    value: function getLanguages(callback) {
      var url = interpolate(this.options.getLanguagesPath, {
        projectId: this.options.projectId
      });
      this.loadUrl(url, {}, callback);
    }
  }, {
    key: "getOptions",
    value: function getOptions(callback) {
      var _this2 = this;

      this.getLanguages(function (err, data) {
        if (err) return callback(err);
        var keys = Object.keys(data);
        if (!keys.length) return callback(new Error('was unable to load languages via API'));
        var referenceLng = keys.reduce(function (mem, k) {
          var item = data[k];
          if (item.isReferenceLanguage) mem = k;
          return mem;
        }, '');
        var whitelist = keys.reduce(function (mem, k) {
          var item = data[k];
          if (item.translated[_this2.options.version] && item.translated[_this2.options.version] >= _this2.options.whitelistThreshold) mem.push(k);
          return mem;
        }, []);
        var hasRegion = keys.reduce(function (mem, k) {
          if (k.indexOf('-') > -1) return true;
          return mem;
        }, false);
        callback(null, {
          fallbackLng: referenceLng,
          referenceLng: referenceLng,
          whitelist: whitelist,
          load: hasRegion ? 'all' : 'languageOnly'
        });
      });
    }
  }, {
    key: "read",
    value: function read(language, namespace, callback) {
      var url;
      var options = {};

      if (this.options["private"]) {
        url = interpolate(this.options.privatePath, {
          lng: language,
          ns: namespace,
          projectId: this.options.projectId,
          version: this.options.version
        });
        options = {
          authorize: true
        };
      } else if (this.options.pull) {
        url = interpolate(this.options.pullPath, {
          lng: language,
          ns: namespace,
          projectId: this.options.projectId,
          version: this.options.version
        });
        options = {
          authorize: true
        };
      } else {
        url = interpolate(this.options.loadPath, {
          lng: language,
          ns: namespace,
          projectId: this.options.projectId,
          version: this.options.version
        });
      }

      this.loadUrl(url, options, callback);
    }
  }, {
    key: "loadUrl",
    value: function loadUrl(url, options, callback) {
      var _this3 = this;

      ajax(url, _objectSpread$1({}, this.options, options), function (data, xhr) {
        if (xhr.status >= 500 && xhr.status < 600) return callback('failed loading ' + url, true
        /* retry */
        );
        if (xhr.status >= 400 && xhr.status < 500) return callback('failed loading ' + url, false
        /* no retry */
        );
        var ret, err;

        try {
          ret = JSON.parse(data);
        } catch (e) {
          err = 'failed parsing ' + url + ' to json';
        }

        if (err) return callback(err, false);
        if (_this3.options.failLoadingOnEmptyJSON && !Object.keys(ret).length) return callback('loaded result empty for ' + url, false);
        callback(null, ret);
      });
    }
  }, {
    key: "create",
    value: function create(languages, namespace, key, fallbackValue, callback, options) {
      var _this4 = this;

      if (!callback) callback = function callback() {};
      if (!this.isAddOrUpdateAllowed) return callback('host is not allowed to create key.');
      if (typeof languages === 'string') languages = [languages];
      languages.forEach(function (lng) {
        if (lng === _this4.options.referenceLng) _this4.queue.call(_this4, _this4.options.referenceLng, namespace, key, fallbackValue, callback, options);
      });
    }
  }, {
    key: "update",
    value: function update(languages, namespace, key, fallbackValue, callback, options) {
      var _this5 = this;

      if (!callback) callback = function callback() {};
      if (!this.isAddOrUpdateAllowed) return callback('host is not allowed to update key.');
      if (!options) options = {};
      if (typeof languages === 'string') languages = [languages]; // mark as update

      options.isUpdate = true;
      languages.forEach(function (lng) {
        if (lng === _this5.options.referenceLng) _this5.queue.call(_this5, _this5.options.referenceLng, namespace, key, fallbackValue, callback, options);
      });
    }
  }, {
    key: "write",
    value: function write(lng, namespace) {
      var _this6 = this;

      var lock = getPath(this.queuedWrites, ['locks', lng, namespace]);
      if (lock) return;
      var missingUrl = interpolate(this.options.addPath, {
        lng: lng,
        ns: namespace,
        projectId: this.options.projectId,
        version: this.options.version
      });
      var updatesUrl = interpolate(this.options.updatePath, {
        lng: lng,
        ns: namespace,
        projectId: this.options.projectId,
        version: this.options.version
      });
      var missings = getPath(this.queuedWrites, [lng, namespace]);
      setPath(this.queuedWrites, [lng, namespace], []);

      if (missings.length) {
        // lock
        setPath(this.queuedWrites, ['locks', lng, namespace], true);
        var hasMissing = false;
        var hasUpdates = false;
        var payloadMissing = {};
        var payloadUpdate = {};
        missings.forEach(function (item) {
          var value = item.options && item.options.tDescription ? {
            value: item.fallbackValue || '',
            context: {
              text: item.options.tDescription
            }
          } : item.fallbackValue || '';

          if (item.options && item.options.isUpdate) {
            if (!hasUpdates) hasUpdates = true;
            payloadUpdate[item.key] = value;
          } else {
            if (!hasMissing) hasMissing = true;
            payloadMissing[item.key] = value;
          }
        });
        var todo = 0;
        if (hasMissing) todo++;
        if (hasUpdates) todo++;

        var doneOne = function doneOne() {
          todo--;

          if (!todo) {
            // unlock
            setPath(_this6.queuedWrites, ['locks', lng, namespace], false);
            missings.forEach(function (missing) {
              if (missing.callback) missing.callback();
            }); // rerun

            _this6.debouncedProcess(lng, namespace);
          }
        };

        if (!todo) doneOne();

        if (hasMissing) {
          ajax(missingUrl, _objectSpread$1({}, {
            authorize: true
          }, this.options), function (data, xhr) {
            //const statusCode = xhr.status.toString();
            // TODO: if statusCode === 4xx do log
            doneOne();
          }, payloadMissing);
        }

        if (hasUpdates) {
          ajax(updatesUrl, _objectSpread$1({}, {
            authorize: true
          }, this.options), function (data, xhr) {
            //const statusCode = xhr.status.toString();
            // TODO: if statusCode === 4xx do log
            doneOne();
          }, payloadUpdate);
        }
      }
    }
  }, {
    key: "process",
    value: function process() {
      var _this7 = this;

      Object.keys(this.queuedWrites).forEach(function (lng) {
        if (lng === 'locks') return;
        Object.keys(_this7.queuedWrites[lng]).forEach(function (ns) {
          var todo = _this7.queuedWrites[lng][ns];

          if (todo.length) {
            _this7.write(lng, ns);
          }
        });
      });
    }
  }, {
    key: "queue",
    value: function queue(lng, namespace, key, fallbackValue, callback, options) {
      pushPath(this.queuedWrites, [lng, namespace], {
        key: key,
        fallbackValue: fallbackValue || '',
        callback: callback,
        options: options
      });
      this.debouncedProcess();
    }
  }]);

  return I18NextLocizeBackend;
}();

I18NextLocizeBackend.type = 'backend';

function debounce$1(func, wait, immediate) {
	var timeout;
	return function () {
		var context = this,
		    args = arguments;
		var later = function later() {
			timeout = null;
			if (!immediate) func.apply(context, args);
		};
		var callNow = immediate && !timeout;
		clearTimeout(timeout);
		timeout = setTimeout(later, wait);
		if (callNow) func.apply(context, args);
	};
}
function replaceIn(str, arr, options) {
	var ret = str;
	arr.forEach(function (s) {
		var regexp = new RegExp('{{' + s + '}}', 'g');
		ret = ret.replace(regexp, options[s]);
	});

	return ret;
}

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

// https://gist.github.com/Xeoncross/7663273
function ajax$1(url, options, callback, data, cache) {
  try {
    var x = new (XMLHttpRequest || ActiveXObject)('MSXML2.XMLHTTP.3.0');
    x.open(data ? 'POST' : 'GET', url, 1);
    if (!options.crossDomain) {
      x.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
    }
    if (options.authorize && options.apiKey) {
      x.setRequestHeader('Authorization', options.apiKey);
    }
    if (data || options.setContentTypeJSON) {
      x.setRequestHeader('Content-type', 'application/json');
    }
    x.onreadystatechange = function () {
      x.readyState > 3 && callback && callback(x.responseText, x);
    };
    x.send(JSON.stringify(data));
  } catch (e) {
    window.console && window.console.log(e);
  }
}
function getDefaults$1() {
  return {
    lastUsedPath: 'https://api.locize.io/used/{{projectId}}/{{version}}/{{lng}}/{{ns}}',
    referenceLng: 'en',
    crossDomain: true,
    setContentTypeJSON: false,
    version: 'latest',
    debounceSubmit: 90000,
    allowedHosts: ['localhost']
  };
}

var locizeLastUsed = {
  init: function init(options) {
    var isI18next = options.t && typeof options.t === 'function';

    this.options = isI18next ? _extends({}, getDefaults$1(), this.options, options.options.locizeLastUsed) : _extends({}, getDefaults$1(), this.options, options);

    var hostname = window.location && window.location.hostname;
    if (hostname) {
      this.isAllowed = this.options.allowedHosts.indexOf(hostname) > -1;
    } else {
      this.isAllowed = true;
    }

    this.submitting = null;
    this.pending = {};
    this.done = {};

    this.submit = debounce$1(this.submit, this.options.debounceSubmit);

    // intercept
    if (isI18next) this.interceptI18next(options);
  },

  interceptI18next: function interceptI18next(i18next) {
    var _this = this;

    var origGetResource = i18next.services.resourceStore.getResource;

    i18next.services.resourceStore.getResource = function (lng, ns, key, options) {
      // call last used
      if (key) _this.used(ns, key);

      // by pass orginal call
      return origGetResource.call(i18next.services.resourceStore, lng, ns, key, options);
    };
  },

  used: function used(ns, key) {
    var _this2 = this;

    ['pending', 'done'].forEach(function (k) {
      if (_this2.done[ns] && _this2.done[ns][key]) return;
      if (!_this2[k][ns]) _this2[k][ns] = {};
      _this2[k][ns][key] = true;
    });

    this.submit();
  },

  submit: function submit() {
    var _this3 = this;

    if (!this.isAllowed) return;
    if (this.submitting) return this.submit();
    this.submitting = this.pending;
    this.pending = {};

    var namespaces = Object.keys(this.submitting);

    var todo = namespaces.length;
    var doneOne = function doneOne() {
      todo--;

      if (!todo) {
        _this3.submitting = null;
      }
    };
    namespaces.forEach(function (ns) {
      var keys = Object.keys(_this3.submitting[ns]);
      var url = replaceIn(_this3.options.lastUsedPath, ['projectId', 'version', 'lng', 'ns'], _extends({}, _this3.options, { lng: _this3.options.referenceLng, ns: ns }));

      if (keys.length) {
        ajax$1(url, _extends({ authorize: true }, _this3.options), function (data, xhr) {
          doneOne();
        }, keys);
      } else {
        doneOne();
      }
    });
  }
};

locizeLastUsed.type = '3rdParty';

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function isWindow(obj) {
  return obj != null && obj === obj.window;
}
function getWindow(elem) {
  return isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
}
function offset(elem) {
  var docElem,
      win,
      box = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  },
      doc = elem && elem.ownerDocument;
  docElem = doc && doc.documentElement;
  if (!docElem) return box;

  if (_typeof(elem.getBoundingClientRect) !== ("undefined")) {
    box = elem.getBoundingClientRect();
  }

  win = getWindow(doc);
  var top = box.top + win.pageYOffset - docElem.clientTop;
  var left = box.left + win.pageXOffset - docElem.clientLeft;
  return {
    top: top,
    left: left,
    right: left + (box.right - box.left),
    bottom: top + (box.bottom - box.top)
  };
}
function getClickedElement(e) {
  // clicked input
  if (e.srcElement && e.srcElement.nodeType === 1) {
    if (e.srcElement.getAttribute && e.srcElement.getAttribute('ignorelocizeeditor') === '') return null;
    return e.srcElement;
  }

  var el;

  if (e.originalEvent && e.originalEvent.explicitOriginalTarget) {
    el = e.originalEvent.explicitOriginalTarget;
  } else {
    var parent = e.srcElement;
    if (parent.getAttribute && parent.getAttribute('ignorelocizeeditor') === '') return null;
    var left = e.pageX;
    var top = e.pageY;
    var pOffset = offset(parent); // console.warn('click', top, left);
    // console.warn('parent', parent, pOffset, parent.clientHeight, parent.offsetHeight);

    var topStartsAt = 0;
    var topBreaksAt;

    for (var i = 0; i < parent.childNodes.length; i++) {
      var n = parent.childNodes[i];
      var nOffset = offset(n); // console.warn('child', n, nOffset, n.clientHeight, n.offsetHeight)
      // if a node is with the bottom over the top click set the next child as start index

      if (n.nodeType === 1 && nOffset.bottom < top) topStartsAt = i + 1; // if node is below top click set end index to this node

      if (!topBreaksAt && nOffset.top + (n.clientHeight || 0) > top) topBreaksAt = i;
    } // check we are inside children lenght


    if (topStartsAt + 1 > parent.childNodes.length) topStartsAt = parent.childNodes.length - 1;
    if (!topBreaksAt) topBreaksAt = parent.childNodes.length; // console.warn('bound', topStartsAt, topBreaksAt)
    // inside our boundaries check when left is to big and out of clicks left

    for (var y = topStartsAt; y < topBreaksAt; y++) {
      var _n = parent.childNodes[y];

      var _nOffset = offset(_n);

      if (_nOffset.left > left) {
        break;
      }

      if (_n && _n.nodeType !== 8) el = _n;
    }
  }

  return el;
}
function removeNamespace(str, i18next) {
  var res = str;
  var nsSeparator = i18next.options.nsSeparator || ':';

  if (str.indexOf(nsSeparator) > -1) {
    var p = str.split(nsSeparator);
    p.shift();
    res = p.join(nsSeparator);
  }

  return res;
}
function getElementNamespace(str, el, i18next) {
  var namespace = i18next.options.defaultNS;
  var nsSeparator = i18next.options.nsSeparator || ':';

  if (str.indexOf(nsSeparator) > -1) {
    namespace = str.split(nsSeparator)[0];
  } else {
    var found;

    var find = function find(el) {
      var opts = el.getAttribute && el.getAttribute('i18next-options');
      if (!opts) opts = el.getAttribute && el.getAttribute('data-i18next-options');
      if (!opts) opts = el.getAttribute && el.getAttribute('i18n-options');
      if (!opts) opts = el.getAttribute && el.getAttribute('data-i18n-options');

      if (opts) {
        var jsonData = {};

        try {
          jsonData = JSON.parse(opts);
        } catch (e) {// not our problem here in editor
        }

        if (jsonData.ns) found = jsonData.ns;
      }

      if (!found) found = el.getAttribute && el.getAttribute('i18next-ns');
      if (!found) found = el.getAttribute && el.getAttribute('data-i18next-ns');
      if (!found) found = el.getAttribute && el.getAttribute('i18n-ns');
      if (!found) found = el.getAttribute && el.getAttribute('data-i18n-ns');
      if (!found && el.parentElement) find(el.parentElement);
    };

    find(el);
    if (found) namespace = found;
  }

  return namespace;
}
function getQueryVariable(variable) {
  var query = window.location.search.substring(1);
  var vars = query.split('&');

  for (var i = 0; i < vars.length; i++) {
    var pair = vars[i].split('=');

    if (pair[0] == variable) {
      return pair[1];
    }
  }

  return false;
}

var baseBtn = 'font-family: "Helvetica", "Arial", sans-serif; font-size: 14px; color: #fff; border: none; font-weight: 300; height: 30px; line-height: 30px; padding: 0; text-align: center; min-width: 90px; text-decoration: none; text-transform: uppercase; text-overflow: ellipsis; white-space: nowrap; outline: none; cursor: pointer;';
function initUI(on, off, options) {
  var cont = document.createElement("div");
  cont.setAttribute('style', 'z-index: 2001; font-family: "Helvetica", "Arial", sans-serif; position: fixed; bottom: 20px; right: 20px; padding: 10px; background-color: #fff; border: solid 1px #1976d2; box-shadow: 0px 1px 2px 0px rgba(0,0,0,0.5);');
  cont.setAttribute('ignorelocizeeditor', '');
  cont.setAttribute('translated', '');
  var title = document.createElement("h4");
  title.id = "locize-title";
  title.innerHTML = "locize editor";
  title.setAttribute('style', 'font-family: "Helvetica", "Arial", sans-serif; font-size: 14px; margin: 0 0 5px 0; color: #1976d2; font-weight: 300;');
  title.setAttribute('ignorelocizeeditor', '');
  cont.appendChild(title);
  var turnOff = document.createElement("button");
  turnOff.innerHTML = "On";
  turnOff.setAttribute('style', "".concat(baseBtn, " display: none; background-color: #54A229;"));
  turnOff.onclick = off;
  turnOff.setAttribute('ignorelocizeeditor', '');
  cont.appendChild(turnOff);
  var turnOn = document.createElement("button");
  turnOn.innerHTML = "Off";
  turnOn.setAttribute('style', "".concat(baseBtn, " display: none; background-color: #D50000;"));
  turnOn.onclick = on;
  turnOn.setAttribute('ignorelocizeeditor', '');
  cont.appendChild(turnOn);
  document.body.appendChild(cont);

  var toggle = function toggle(on) {
    turnOff.style.display = on ? 'block' : 'none';
    turnOn.style.display = !on ? 'block' : 'none';
  };

  return toggle;
}
function appendIframe(url, options) {
  var cont = document.createElement("div");
  cont.setAttribute('style', options.iframeContainerStyle);
  cont.setAttribute('ignorelocizeeditor', '');
  cont.setAttribute('translated', '');
  var iframe = document.createElement("iframe");
  iframe.setAttribute('style', options.iframeStyle);
  iframe.setAttribute('ignorelocizeeditor', '');
  iframe.setAttribute('translated', '');
  iframe.setAttribute('src', url);
  cont.appendChild(iframe);
  document.body.appendChild(cont);
  var bodyStyle = document.body.getAttribute('style');
  document.body.setAttribute('style', "".concat(bodyStyle, "; ").concat(options.bodyStyle));
  return iframe.contentWindow;
}

var defaultOptions = {
  url: 'https://www.locize.io',
  enabled: false,
  enableByQS: 'locize',
  toggleKeyCode: 24,
  toggleKeyModifier: 'ctrlKey',
  lngOverrideQS: 'useLng',
  lngOverride: null,
  autoOpen: true,
  onEditorSaved: function onEditorSaved(lng, ns) {},
  mode: getQueryVariable('locizeMode') || 'iframe',
  iframeContainerStyle: 'z-index: 2000; position: fixed; top: 0; right: 0; bottom: 0; width: 600px; box-shadow: -3px 0 5px 0 rgba(0,0,0,0.5);',
  iframeStyle: 'height: 100%; width: 600px; border: none;',
  bodyStyle: 'margin-right: 605px;'
};

function convertOptionsToI18next(opts) {
  return {
    languages: [opts.lng],
    nsSeparator: opts.nsSeparator || ':',
    options: {
      editor: opts,
      backend: opts,
      defaultNS: opts.defaultNS
    }
  };
}

var editor = {
  type: '3rdParty',
  init: function init(i18next) {
    var _this = this;

    // convert standalone options
    if (i18next && !i18next.init) i18next = convertOptionsToI18next(i18next);
    this.enabled = false;
    this.i18next = i18next;
    this.options = _objectSpread$1({}, defaultOptions, i18next.options.editor);
    this.locizeUrl = i18next.options.editor && i18next.options.editor.url || 'https://www.locize.io';
    this.handler = this.handler.bind(this);

    if (this.options.enabled || this.options.enableByQS && getQueryVariable(this.options.enableByQS) === 'true') {
      setTimeout(function () {
        _this.toggleUI = initUI(_this.on.bind(_this), _this.off.bind(_this), _this.options);
        if (_this.options.autoOpen) _this.open();

        _this.on();
      }, 500);
    }

    document.addEventListener('keypress', function (e) {
      if (e[_this.options.toggleKeyModifier] && e.which === _this.options.toggleKeyCode) _this.enabled ? _this.off() : _this.on();
    }); // listen to key press on locize service to disable

    window.addEventListener('message', function (e) {
      if (e.data[_this.options.toggleKeyModifier] && e.data.which === _this.options.toggleKeyCode) _this.enabled ? _this.off() : _this.on();

      if (e.data.type === 'savedSegments') {
        _this.options.onEditorSaved(e.data.lng, e.data.ns);
      }
    });
  },
  handler: function handler(e) {
    var _this2 = this;

    var el = getClickedElement(e);
    if (!el) return;
    e.preventDefault();
    e.stopPropagation();
    var str = el.textContent || el.text && el.text.innerText || el.placeholder;
    if (typeof str !== "string") return;
    var res = str.replace(/\n +/g, '').trim();

    var send = function send() {
      // consume
      // window.addEventListener('message', function(ev) {
      //   if (ev.data.message === 'searchForKey') {
      //     console.warn(ev.data);
      //   }
      // });
      var payload = {
        message: 'searchForKey',
        projectId: _this2.i18next.options.backend.projectId,
        version: _this2.i18next.options.backend.version || 'latest',
        lng: getQueryVariable(_this2.options.lngOverrideQS) || _this2.options.lngOverride || _this2.i18next.languages[0],
        ns: getElementNamespace(res, el, _this2.i18next),
        token: removeNamespace(res, _this2.i18next)
      };
      if (!payload.lng || payload.lng.toLowerCase() === 'cimode') payload.lng = _this2.i18next.options.backend.referenceLng;
      if (_this2.options.handler) return _this2.options.handler(payload);

      _this2.locizeInstance.postMessage(payload, _this2.options.url);

      _this2.locizeInstance.focus();
    }; // assert the locizeInstance is still open


    if (this.options.autoOpen && (this.options.mode !== 'iframe' && !this.locizeInstance || this.locizeInstance.closed)) {
      this.open();
      setTimeout(function () {
        send();
      }, 3000);
    } else {
      send();
    }
  },
  open: function open() {
    if (this.options.mode === "iframe") return this.locizeInstance = appendIframe(this.options.url, this.options);
    this.locizeInstance = window.open(this.options.url);
  },
  on: function on() {
    document.body.addEventListener("click", this.handler, true);
    this.toggleUI(true);
    this.enabled = true;
  },
  off: function off() {
    document.body.removeEventListener("click", this.handler, true);
    this.toggleUI(false);
    this.enabled = false;
  }
};

var debugMode = !!(process.env.NODE_ENV !== 'production' && process.env.REACT_APP_I18N_DEBUG);
var detectionOptions = {
  // order and from where user language should be detected
  order: ['querystring', 'cookie', 'localStorage', 'navigator', 'htmlTag', 'path', 'subdomain'],
  // keys or params to lookup language from
  lookupQuerystring: 'lng',
  lookupCookie: 'i18next',
  lookupLocalStorage: 'i18nextLng',
  lookupFromPathIndex: 0,
  lookupFromSubdomainIndex: 0,
  // cache user language on
  caches: ['localStorage', 'cookie'],
  excludeCacheFor: ['cimode'],
  // languages to not persist (cookie, localStorage)
  // optional htmlTag with lang attribute, the default is:
  htmlTag: document.documentElement
};

var customDebug = (function (message) {
  var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'log';

  if (debugMode) {
    // eslint-disable-next-line
    console[level]('@ohif/i18n: ', message);
  }
});

var name="@ohif/i18n";var version="0.2.5";var description="OHIF extension for internationalization";var author="OHIF";var license="MIT";var repository="OHIF/Viewers";var main="dist/index.umd.js";var module="dist/index.es.js";var engines={node:">=8",npm:">=5"};var scripts={build:"rollup -c",prepublishOnly:"npm run build",pullTranslations:"./pullTranslations.sh"};var peerDependencies={i18next:"^17.0.3","i18next-browser-languagedetector":"^3.0.1",react:"^16.0.0","react-dom":"^16.0.0","react-i18next":"^10.11.0"};var devDependencies={"@babel/core":"^7.2.2","@babel/plugin-external-helpers":"^7.2.0","@babel/plugin-proposal-class-properties":"^7.2.3","@babel/plugin-transform-runtime":"^7.2.0","@babel/preset-env":"^7.2.3","@babel/preset-react":"^7.0.0","babel-eslint":"^10.0.1","cross-env":"^5.2.0",eslint:"5.13.0","eslint-plugin-import":"^2.14.0","eslint-plugin-node":"^8.0.0","eslint-plugin-promise":"^4.0.1","eslint-plugin-react":"^7.11.1",husky:"^1.3.1",i18next:"^15.1.3","i18next-browser-languagedetector":"^3.0.1","lint-staged":"^8.1.0","locize-cli":"^4.8.0",prettier:"^1.15.3",react:"^16.0.0","react-dom":"^16.0.0","react-i18next":"^10.11.0",rollup:"^1.1.2","rollup-plugin-babel":"^4.2.0","rollup-plugin-commonjs":"^9.2.0","rollup-plugin-node-builtins":"^2.1.2","rollup-plugin-node-resolve":"^4.0.0","rollup-plugin-peer-deps-external":"^2.2.0","rollup-plugin-postcss":"^2.0.3","rollup-plugin-url":"^2.1.0"};var husky={hooks:{"pre-commit":"lint-staged"}};var browserslist=[">0.2%","not dead","not ie <= 11","not op_mini all"];var files=["dist"];var publishConfig={access:"public"};var dependencies={"@babel/runtime":"^7.2.0",classnames:"^2.2.6","i18next-locize-backend":"^2.0.0","locize-editor":"^2.0.0","locize-lastused":"^1.1.0","rollup-plugin-json":"^4.0.0"};var pkg = {name:name,version:version,description:description,author:author,license:license,repository:repository,main:main,module:module,"jsnext:main":"dist/index.es.js",engines:engines,scripts:scripts,peerDependencies:peerDependencies,devDependencies:devDependencies,husky:husky,"lint-staged":{"src/**/*.{js,jsx,json,css}":["prettier --single-quote --write","git add"]},browserslist:browserslist,files:files,publishConfig:publishConfig,dependencies:dependencies};

var Acquired="Acquired";var Angle="Angle";var Axial="Axial";var Bidirectional="Bidirectional";var Brush="Brush";var CINE="CINE";var Cancel="Cancel";var Circle="Circle";var Clear="Clear";var Coronal="Coronal";var Crosshairs="Crosshairs";var Ellipse="Ellipse";var Elliptical="Elliptical";var Freehand="Freehand";var Invert="Invert";var Layout="$t(Common:Layout)";var Length="Length";var Levels="Levels";var Magnify="Magnify";var Manual="Manual";var Measurements="Measurements";var More="$t(Common:More)";var Next="$t(Common:Next)";var Pan="Pan";var Play="$t(Common:Play)";var Previous="$t(Common:Previous)";var Probe="Probe";var Rectangle="Rectangle";var Reset="$t(Common:Reset)";var Sagittal="Sagittal";var Save="Save";var Stop="$t(Common:Stop)";var Themes="Themes";var Zoom="Zoom";var Buttons = {Acquired:Acquired,Angle:Angle,Axial:Axial,Bidirectional:Bidirectional,Brush:Brush,CINE:CINE,Cancel:Cancel,Circle:Circle,Clear:Clear,Coronal:Coronal,Crosshairs:Crosshairs,Ellipse:Ellipse,Elliptical:Elliptical,"Flip H":"Flip H","Flip V":"Flip V",Freehand:Freehand,Invert:Invert,Layout:Layout,Length:Length,Levels:Levels,Magnify:Magnify,Manual:Manual,Measurements:Measurements,More:More,Next:Next,Pan:Pan,Play:Play,Previous:Previous,Probe:Probe,"ROI Window":"ROI Window",Rectangle:Rectangle,Reset:Reset,"Reset to Defaults":"$t(Common:Reset) to Defaults","Rotate Right":"Rotate Right",Sagittal:Sagittal,Save:Save,"Stack Scroll":"Stack Scroll",Stop:Stop,Themes:Themes,Zoom:Zoom};

var fps="fps";var CineDialog = {"Next image":"$t(Common:Play) $t(Common:Image)","Play / Stop":"$t(Common:Play) / $t(Common:Stop)","Previous image":"$t(Common:Previous) $t(Common:Image)","Skip to first image":"Skip to first $t(Common:Image)","Skip to last image":"Skip, to last $t(Common:Image)",fps:fps};

var Image="Image";var Layout$1="Layout";var Measurements$1="Measurements";var More$1="More";var Next$1="Next";var Play$1="Play";var Previous$1="Previous";var Reset$1="Reset";var RowsPerPage="rows per page";var Series="Series";var Show="Show";var Stop$1="Stop";var StudyDate="Study Date";var Common = {Image:Image,Layout:Layout$1,Measurements:Measurements$1,More:More$1,Next:Next$1,Play:Play$1,Previous:Previous$1,Reset:Reset$1,RowsPerPage:RowsPerPage,Series:Series,Show:Show,Stop:Stop$1,StudyDate:StudyDate};

var About="About";var Options="Options";var Preferences="Preferences";var Header = {About:About,"Back to Viewer":"Back to Viewer","INVESTIGATIONAL USE ONLY":"INVESTIGATIONAL USE ONLY",Options:Options,Preferences:Preferences,"Study list":"Study list"};

var Delete="Delete";var Description="Description";var MAX="MAX";var NonTargets="NonTargets";var Relabel="Relabel";var Targets="Targets";var MeasurementTable = {"Criteria nonconformities":"Criteria nonconformities",Delete:Delete,Description:Description,MAX:MAX,NonTargets:NonTargets,Relabel:Relabel,Targets:Targets};

var AccessionNumber="Accession #";var Empty="Empty";var MRN="MRN";var Modality="Modality";var PatientName="Patient Name";var StudyDate$1="Study Date";var StudyDescription="Description";var StudyList="Study List";var StudyList$1 = {AccessionNumber:AccessionNumber,Empty:Empty,MRN:MRN,Modality:Modality,PatientName:PatientName,StudyDate:StudyDate$1,StudyDescription:StudyDescription,StudyList:StudyList};

var Cancel$1="$t(Buttons:Cancel)";var Save$1="$t(Buttons:Save)";var UserPreferencesModal = {Cancel:Cancel$1,"Reset to Defaults":"$t(Buttons:Reset to Defaults)",Save:Save$1,"User Preferences":"User Preferences"};

var en_US = {
  'en-US': {
    Buttons: Buttons,
    CineDialog: CineDialog,
    Common: Common,
    Header: Header,
    MeasurementTable: MeasurementTable,
    StudyList: StudyList$1,
    UserPreferencesModal: UserPreferencesModal
  }
};

var Acquired$1="Adquirido";var Angle$1="ngulo";var Axial$1="Axial";var Bidirectional$1="Bidireccional";var Brush$1="Cepillo";var CINE$1="CINE";var Cancel$2="Cancelar";var Circle$1="Crculo";var Clear$1="Limpiar";var Coronal$1="Coronal";var Crosshairs$1="Punto de mira";var Ellipse$1="Elipse";var Elliptical$1="Elptico";var Freehand$1="Mano alzada";var Invert$1="Invertir";var Layout$2="$t(Common:Layout)";var Length$1="Longitud";var Levels$1="Niveles";var Magnify$1="Aumentar";var Manual$1="Manual";var Measurements$2="Mediciones";var More$2="$t(Common:More)";var Next$2="$t(Common:Next)";var Pan$1="Mover";var Play$2="$t(Common:Play)";var Previous$2="$t(Common:Previous)";var Probe$1="Probar";var Rectangle$1="Rectngulo";var Reset$2="$t(Common:Reset)";var Sagittal$1="Sagital";var Save$2="Guardar";var Stop$2="$t(Common:Stop)";var Themes$1="Temas";var Zoom$1="Zoom";var Buttons$1 = {Acquired:Acquired$1,Angle:Angle$1,Axial:Axial$1,Bidirectional:Bidirectional$1,Brush:Brush$1,CINE:CINE$1,Cancel:Cancel$2,Circle:Circle$1,Clear:Clear$1,Coronal:Coronal$1,Crosshairs:Crosshairs$1,Ellipse:Ellipse$1,Elliptical:Elliptical$1,"Flip H":"Espejo H","Flip V":"Espejo V",Freehand:Freehand$1,Invert:Invert$1,Layout:Layout$2,Length:Length$1,Levels:Levels$1,Magnify:Magnify$1,Manual:Manual$1,Measurements:Measurements$2,More:More$2,Next:Next$2,Pan:Pan$1,Play:Play$2,Previous:Previous$2,Probe:Probe$1,"ROI Window":"Ventana ROI",Rectangle:Rectangle$1,Reset:Reset$2,"Reset to Defaults":"$t(Common:Reset) por defecto","Rotate Right":"Rotar ->",Sagittal:Sagittal$1,Save:Save$2,"Stack Scroll":"Scroll en pila",Stop:Stop$2,Themes:Themes$1,Zoom:Zoom$1};

var fps$1="imgenes/seg.";var CineDialog$1 = {"Next image":" $t(Common:Image) $t(Common:Next)","Play / Stop":"$t(Common:Play) / Stop","Previous image":"$t(Common:Image) $t(Common:Previous)","Skip to first image":"Ir a la primera $t(Common:Image)","Skip to last image":"Ir a la ltima $t(Common:Image)",fps:fps$1};

var Image$1="Imagen";var Layout$3="Disposicin";var Measurements$3="Medidas";var More$3="Ms";var Next$3="Siguiente";var Play$3="Play";var Previous$3="Anterior";var Reset$3="Resetear";var RowsPerPage$1="filas por pgina";var Series$1="Secuencia";var Show$1="Mostrar";var Stop$3="Detener";var StudyDate$2="Fecha de estudo";var Common$1 = {Image:Image$1,Layout:Layout$3,Measurements:Measurements$3,More:More$3,Next:Next$3,Play:Play$3,Previous:Previous$3,Reset:Reset$3,RowsPerPage:RowsPerPage$1,Series:Series$1,Show:Show$1,Stop:Stop$3,StudyDate:StudyDate$2};

var About$1="Acerca de";var Options$1="Opciones";var Preferences$1="Preferencias";var Header$1 = {About:About$1,"Back to Viewer":"Volver al visor","INVESTIGATIONAL USE ONLY":"SOLO USO PARA INVESTIGACIN",Options:Options$1,Preferences:Preferences$1,"Study list":"Lista de estudios"};

var Delete$1="Borrar";var Description$1="Descripcin";var MAX$1="Mximo";var NonTargets$1="No objetivos";var Relabel$1="Re-etiquetar";var Targets$1="Objetivos";var MeasurementTable$1 = {"Criteria nonconformities":"Criterios disconformes",Delete:Delete$1,Description:Description$1,MAX:MAX$1,NonTargets:NonTargets$1,Relabel:Relabel$1,Targets:Targets$1};

var AccessionNumber$1="Nmero de Adhesin";var Empty$1="vaco";var MRN$1="MRN";var Modality$1="Modalidad";var PatientName$1="Nombre del paciente";var StudyDate$3="Fetcha de estudio";var StudyDescription$1="Descripcin";var StudyList$2="Lista de Estudio";var StudyList$3 = {AccessionNumber:AccessionNumber$1,Empty:Empty$1,MRN:MRN$1,Modality:Modality$1,PatientName:PatientName$1,StudyDate:StudyDate$3,StudyDescription:StudyDescription$1,StudyList:StudyList$2};

var Cancel$3="$t(Buttons:Cancel)";var Save$3="$t(Buttons:Save)";var UserPreferencesModal$1 = {Cancel:Cancel$3,"Reset to Defaults":"$t(Buttons:Reset to Defaults)",Save:Save$3,"User Preferences":"Preferencias de Usuario"};

var es = {
  'es': {
    Buttons: Buttons$1,
    CineDialog: CineDialog$1,
    Common: Common$1,
    Header: Header$1,
    MeasurementTable: MeasurementTable$1,
    StudyList: StudyList$3,
    UserPreferencesModal: UserPreferencesModal$1
  }
};

var Circle$2="Cirkel";var More$4="Meer";var Pan$2="Pan";var Zoom$2="Inzoomen";var Buttons$2 = {Circle:Circle$2,More:More$4,Pan:Pan$2,Zoom:Zoom$2};

var More$5="Meer";var Common$2 = {More:More$5};

var About$2="Over";var Options$2="Opties";var Preferences$2="Voorkeuren";var Header$2 = {About:About$2,"INVESTIGATIONAL USE ONLY":"ALLEEN VOOR ONDERZOEK",Options:Options$2,Preferences:Preferences$2,"Study list":"Studie Overzicht"};

var nl = {
  'nl': {
    Buttons: Buttons$2,
    Common: Common$2,
    Header: Header$2
  }
};

var Acquired$2="Adquirido";var Angle$2="ngulo";var Axial$2="Axial";var Bidirectional$2="Bidirecional";var Brush$2="Pincel";var CINE$2="CINE";var Cancel$4="Cancelar";var Circle$3="Crculo";var Clear$2="Limpar";var Coronal$2="Coronal";var Crosshairs$2="Localizador";var Ellipse$2="Elipse";var Elliptical$2="Elptico";var Freehand$2="Desenho livre";var Invert$2="Inverter";var Layout$4="Layout";var Length$2="Tamanho";var Levels$2="Nveis";var Magnify$2="Ampliar";var Manual$2="Manual";var Measurements$4="Medidas";var More$6="Mais";var Next$4="Prximo";var Pan$3="Arrastar";var Play$4="Tocar";var Previous$4="Anterior";var Probe$2="Prova";var Rectangle$2="Retngulo";var Reset$4="Resetar";var Sagittal$2="Sagital";var Save$4="Salvar";var Stop$4="Parar";var Themes$2="Temas";var Zoom$3="Zoom";var Buttons$3 = {Acquired:Acquired$2,Angle:Angle$2,Axial:Axial$2,Bidirectional:Bidirectional$2,Brush:Brush$2,CINE:CINE$2,Cancel:Cancel$4,Circle:Circle$3,Clear:Clear$2,Coronal:Coronal$2,Crosshairs:Crosshairs$2,Ellipse:Ellipse$2,Elliptical:Elliptical$2,"Flip H":"Inverter H","Flip V":"Inverter V",Freehand:Freehand$2,Invert:Invert$2,Layout:Layout$4,Length:Length$2,Levels:Levels$2,Magnify:Magnify$2,Manual:Manual$2,Measurements:Measurements$4,More:More$6,Next:Next$4,Pan:Pan$3,Play:Play$4,Previous:Previous$4,Probe:Probe$2,"ROI Window":"Janela ROI",Rectangle:Rectangle$2,Reset:Reset$4,"Reset to Defaults":"Restaurar para o Padro","Rotate Right":"Girar  direita",Sagittal:Sagittal$2,Save:Save$4,"Stack Scroll":"Navegar Stacks",Stop:Stop$4,Themes:Themes$2,Zoom:Zoom$3};

var fps$2="fps";var CineDialog$2 = {"Next image":"Prxima imagem","Play / Stop":"Tocar / Parar","Previous image":"Imagem Anterior","Skip to first image":"Pular para a primeira imagem","Skip to last image":"Pular para a ltima imagem",fps:fps$2};

var Image$2="Imagem";var Layout$5="Layout";var More$7="Mais";var Next$5="Prximo";var Play$5="Play";var Previous$5="Anterior";var Reset$5="Reset";var Stop$5="Stop";var Common$3 = {Image:Image$2,Layout:Layout$5,More:More$7,Next:Next$5,Play:Play$5,Previous:Previous$5,Reset:Reset$5,Stop:Stop$5};

var About$3="Quem somos";var Options$3="Opes";var Preferences$3="Preferncias";var Header$3 = {About:About$3,"Back to Viewer":"Voltar para o Viewer","INVESTIGATIONAL USE ONLY":"APENAS PARA USO INVESTIGATIVO",Options:Options$3,Preferences:Preferences$3,"Study list":"Lista de estudos"};

var Cancel$5="Cancelar";var Save$5="Salvar";var UserPreferencesModal$2 = {Cancel:Cancel$5,"Reset to Defaults":"Restaurar Default",Save:Save$5,"User Preferences":"Preferncias do Usurio"};

var pt_BR = {
  'pt-BR': {
    Buttons: Buttons$3,
    CineDialog: CineDialog$2,
    Common: Common$3,
    Header: Header$3,
    UserPreferencesModal: UserPreferencesModal$2
  }
};

var Acquired$3=" ly";var Angle$3="Gc";var Axial$3="Trc";var Bidirectional$3="Hai hng";var Brush$3="Bt lng";var CINE$3="Duyt t ng";var Cancel$6="Hy b";var Circle$4="Vng trn";var Clear$3="Xa";var Coronal$3="Mt phng vnh";var Crosshairs$3="V tr tng quan";var Ellipse$3="o Elip";var Elliptical$3="Elip";var Freehand$3="Bng tay";var Invert$3="nh dng bn";var Layout$6="$t(Common:Layout)";var Length$3="Thc o chiu di";var Levels$3=" sng";var Magnify$3="Phng i mt phn";var Manual$3="Th cng";var Measurements$5="o lng";var More$8="$t(Common:More)";var Next$6="$t(Common:Next)";var Pan$4="Di chuyn";var Play$6="$t(Common:Play)";var Previous$6="$t(Common:Previous)";var Probe$3="Thng tin im nh";var Rectangle$3="o ch nht";var Reset$6="$t(Common:Reset)";var Sagittal$3="Mt phng ng dc";var Save$6="Lu";var Stop$6="$t(Common:Stop)";var Themes$3="Giao din";var Zoom$4="Thu phng";var Buttons$4 = {Acquired:Acquired$3,Angle:Angle$3,Axial:Axial$3,Bidirectional:Bidirectional$3,Brush:Brush$3,CINE:CINE$3,Cancel:Cancel$6,Circle:Circle$4,Clear:Clear$3,Coronal:Coronal$3,Crosshairs:Crosshairs$3,Ellipse:Ellipse$3,Elliptical:Elliptical$3,"Flip H":"Lt ngang","Flip V":"Lt dc",Freehand:Freehand$3,Invert:Invert$3,Layout:Layout$6,Length:Length$3,Levels:Levels$3,Magnify:Magnify$3,Manual:Manual$3,Measurements:Measurements$5,More:More$8,Next:Next$6,Pan:Pan$4,Play:Play$6,Previous:Previous$6,Probe:Probe$3,"ROI Window":"ROI Window",Rectangle:Rectangle$3,Reset:Reset$6,"Reset to Defaults":"$t(Common:Reset) n mc nh","Rotate Right":"Xoay phi",Sagittal:Sagittal$3,Save:Save$6,"Stack Scroll":"Duyt",Stop:Stop$6,Themes:Themes$3,Zoom:Zoom$4};

var fps$3="fps";var CineDialog$3 = {"Next image":"$t(Common:Play) $t(Common:Image)","Play / Stop":"$t(Common:Play) / $t(Common:Stop)","Previous image":"$t(Common:Previous) $t(Common:Image)","Skip to first image":"B qua n u $t(Common:Image)","Skip to last image":"B qua n cui $t(Common:Image)",fps:fps$3};

var Image$3="nh";var Layout$7="Cch b tr";var Measurements$6="o lng";var More$9="Thm";var Next$7="Tip theo";var Play$7="Pht";var Previous$7="V sau";var Reset$7="t li";var RowsPerPage$2="trn 1 trang";var Series$2="Tp nh";var Show$2="Hin th";var Stop$7="Dng";var StudyDate$4="Ngy chp";var Common$4 = {Image:Image$3,Layout:Layout$7,Measurements:Measurements$6,More:More$9,Next:Next$7,Play:Play$7,Previous:Previous$7,Reset:Reset$7,RowsPerPage:RowsPerPage$2,Series:Series$2,Show:Show$2,Stop:Stop$7,StudyDate:StudyDate$4};

var About$4="V chng ti";var Options$4="La chn";var Preferences$4="Thit lp";var Header$4 = {About:About$4,"Back to Viewer":"nh va xem","INVESTIGATIONAL USE ONLY":"Ch dng cho nghin cu",Options:Options$4,Preferences:Preferences$4,"Study list":"Danh sch"};

var AccessionNumber$2="M phiu";var Empty$2="Rng";var MRN$2="M Bnh nhn";var Modality$2="Thit b";var PatientName$2="Tn Bnh nhn";var StudyDate$5="Ngy chp";var StudyDescription$2="Din gii";var StudyList$4="Danh sch";var StudyList$5 = {AccessionNumber:AccessionNumber$2,Empty:Empty$2,MRN:MRN$2,Modality:Modality$2,PatientName:PatientName$2,StudyDate:StudyDate$5,StudyDescription:StudyDescription$2,StudyList:StudyList$4};

var Cancel$7="$t(Buttons:Cancel)";var Save$7="$t(Buttons:Save)";var UserPreferencesModal$3 = {Cancel:Cancel$7,"Reset to Defaults":"$t(Buttons:Reset to Defaults)",Save:Save$7,"User Preferences":"Thit lp theo ngi dng"};

var vi = {
  'vi': {
    Buttons: Buttons$4,
    CineDialog: CineDialog$3,
    Common: Common$4,
    Header: Header$4,
    StudyList: StudyList$5,
    UserPreferencesModal: UserPreferencesModal$3
  }
};

var Acquired$4="";var Angle$4="";var Axial$4="";var Bidirectional$4="";var Brush$4="";var CINE$4="";var Cancel$8="";var Circle$5="";var Clear$4="";var Coronal$4="";var Crosshairs$4="";var Ellipse$4="";var Elliptical$4="";var Freehand$4="";var Invert$4="";var Layout$8="";var Length$4="";var Levels$4="";var Magnify$4="";var Manual$4="";var Measurements$7="";var More$a="";var Next$8="";var Pan$5="";var Play$8="";var Previous$8="";var Probe$4="";var Rectangle$4="";var Reset$8="";var Sagittal$4="";var Save$8="";var Stop$8="";var Themes$4="";var Zoom$5="";var Buttons$5 = {Acquired:Acquired$4,Angle:Angle$4,Axial:Axial$4,Bidirectional:Bidirectional$4,Brush:Brush$4,CINE:CINE$4,Cancel:Cancel$8,Circle:Circle$5,Clear:Clear$4,Coronal:Coronal$4,Crosshairs:Crosshairs$4,Ellipse:Ellipse$4,Elliptical:Elliptical$4,"Flip H":"","Flip V":"",Freehand:Freehand$4,Invert:Invert$4,Layout:Layout$8,Length:Length$4,Levels:Levels$4,Magnify:Magnify$4,Manual:Manual$4,Measurements:Measurements$7,More:More$a,Next:Next$8,Pan:Pan$5,Play:Play$8,Previous:Previous$8,Probe:Probe$4,"ROI Window":"",Rectangle:Rectangle$4,Reset:Reset$8,"Reset to Defaults":"","Rotate Right":"",Sagittal:Sagittal$4,Save:Save$8,"Stack Scroll":"",Stop:Stop$8,Themes:Themes$4,Zoom:Zoom$5};

var fps$4="";var CineDialog$4 = {"Next image":"","Play / Stop":"/","Previous image":"","Skip to first image":"","Skip to last image":"",fps:fps$4};

var Image$4="";var Layout$9="";var Measurements$8="";var More$b="";var Next$9="";var Play$9="";var Previous$9="";var Reset$9="";var RowsPerPage$3="";var Series$3="";var Show$3="";var Stop$9="";var StudyDate$6="";var Common$5 = {Image:Image$4,Layout:Layout$9,Measurements:Measurements$8,More:More$b,Next:Next$9,Play:Play$9,Previous:Previous$9,Reset:Reset$9,RowsPerPage:RowsPerPage$3,Series:Series$3,Show:Show$3,Stop:Stop$9,StudyDate:StudyDate$6};

var About$5="";var Options$5="";var Preferences$5="";var Header$5 = {About:About$5,"Back to Viewer":"","INVESTIGATIONAL USE ONLY":"",Options:Options$5,Preferences:Preferences$5,"Study list":""};

var Delete$2="";var Description$2="";var MAX$2="";var NonTargets$2="";var Relabel$2="";var Targets$2="";var MeasurementTable$2 = {"Criteria nonconformities":"",Delete:Delete$2,Description:Description$2,MAX:MAX$2,NonTargets:NonTargets$2,Relabel:Relabel$2,Targets:Targets$2};

var Empty$3="";var Modality$3="";var PatientName$3="";var StudyDate$7="";var StudyDescription$3="";var StudyList$6="";var StudyList$7 = {Empty:Empty$3,Modality:Modality$3,PatientName:PatientName$3,StudyDate:StudyDate$7,StudyDescription:StudyDescription$3,StudyList:StudyList$6};

var Cancel$9="";var Save$9="";var UserPreferencesModal$4 = {Cancel:Cancel$9,"Reset to Defaults":"",Save:Save$9,"User Preferences":""};

var zh = {
  'zh': {
    Buttons: Buttons$5,
    CineDialog: CineDialog$4,
    Common: Common$5,
    Header: Header$5,
    MeasurementTable: MeasurementTable$2,
    StudyList: StudyList$7,
    UserPreferencesModal: UserPreferencesModal$4
  }
};

var locales = objectSpread({}, en_US, es, nl, pt_BR, vi, zh);

function addLocales(newLocales) {
  customDebug("Adding locales ".concat(newLocales), 'info');
  var resourceBundle = [];
  Object.keys(newLocales).map(function (key) {
    Object.keys(newLocales[key]).map(function (namespace) {
      var locale = newLocales[key][namespace];
      resourceBundle.push({
        key: key,
        namespace: namespace,
        locale: locale
      });
      i18n.addResourceBundle(key, namespace, locale, true, true);
    });
  });
  customDebug("Locales added successfully", 'info');
  customDebug(resourceBundle, 'info');
} // Note: Developers can add the API key to use the in-context editor.
// DO NOT commit the API key


var config = window.config && window.config.i18n || {};
var locizeOptions = {
  projectId: config.LOCIZE_PROJECTID,
  apiKey: config.LOCIZE_API_KEY,
  referenceLng: 'en-US',
  fallbacklng: 'en-US'
};
var envUseLocize = !!config.USE_LOCIZE;
var envApiKeyAvailable = !!config.LOCIZE_API_KEY;

function initI18n() {
  var detection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : detectionOptions;
  var useLocize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : envUseLocize;
  var apiKeyAvailable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : envApiKeyAvailable;
  var initialized;

  if (useLocize) {
    customDebug("Using Locize for translation files", 'info');
    initialized = i18n // i18next-locize-backend
    // loads translations from your project, saves new keys to it (saveMissing: true)
    // https://github.com/locize/i18next-locize-backend
    .use(I18NextLocizeBackend) // locize-lastused
    // sets a timestamp of last access on every translation segment on locize
    // -> safely remove the ones not being touched for weeks/months
    // https://github.com/locize/locize-lastused
    .use(locizeLastUsed) // locize-editor
    // InContext Editor of locize ?locize=true to show it
    // https://github.com/locize/locize-editor
    .use(editor) // detect user language
    // learn more: https://github.com/i18next/i18next-browser-languageDetector
    .use(LanguageDetector) // pass the i18n instance to react-i18next.
    .use(initReactI18next) // init i18next
    // for all options read: https://www.i18next.com/overview/configuration-options
    .init({
      fallbackLng: 'en-US',
      saveMissing: apiKeyAvailable,
      debug: debugMode,
      keySeparator: false,
      interpolation: {
        escapeValue: false // not needed for react as it escapes by default

      },
      detection: detection,
      backend: locizeOptions,
      locizeLastUsed: locizeOptions,
      editor: objectSpread({}, locizeOptions, {
        onEditorSaved: function () {
          var _onEditorSaved = asyncToGenerator(
          /*#__PURE__*/
          regenerator.mark(function _callee(lng, ns) {
            return regenerator.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return i18n.reloadResources(lng, ns);

                  case 2:
                    // trigger an event on i18n which triggers a rerender
                    // based on bindI18n below in react options
                    i18n.emit('editorSaved');

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function onEditorSaved(_x, _x2) {
            return _onEditorSaved.apply(this, arguments);
          }

          return onEditorSaved;
        }()
      }),
      react: {
        useSuspense: false,
        // TODO: Was seeing weird errors without this
        wait: true,
        bindI18n: 'languageChanged editorSaved'
      }
    });
  } else {
    customDebug("Using local translation files", 'info');
    initialized = i18n // detect user language
    // learn more: https://github.com/i18next/i18next-browser-languageDetector
    .use(LanguageDetector) // pass the i18n instance to react-i18next.
    .use(initReactI18next) // init i18next
    // for all options read: https://www.i18next.com/overview/configuration-options
    .init({
      fallbackLng: 'en-US',
      resources: locales,
      debug: debugMode,
      keySeparator: false,
      interpolation: {
        escapeValue: false // not needed for react as it escapes by default

      },
      detection: detection,
      react: {
        wait: true
      }
    });
  }

  return initialized.then(function (t) {
    i18n.T = t;
    customDebug("T function available.", 'info');
  });
}

customDebug("version ".concat(pkg.version, " loaded."), 'info');
i18n.initializing = initI18n();
i18n.initI18n = initI18n;
i18n.addLocales = addLocales;

export default i18n;
//# sourceMappingURL=index.es.js.map
